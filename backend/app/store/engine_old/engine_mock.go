// Code generated by mockery v1.0.0. DO NOT EDIT.
package engine_old

import mock "github.com/stretchr/testify/mock"
import store "github.com/umputun/remark/backend/app/store"
import time "time"

// MockInterface is an autogenerated mock type for the Interface type
type MockInterface struct {
	mock.Mock
}

// Blocked provides a mock function with given fields: siteID
func (_m *MockInterface) Blocked(siteID string) ([]store.BlockedUser, error) {
	ret := _m.Called(siteID)

	var r0 []store.BlockedUser
	if rf, ok := ret.Get(0).(func(string) []store.BlockedUser); ok {
		r0 = rf(siteID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]store.BlockedUser)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(siteID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Close provides a mock function with given fields:
func (_m *MockInterface) Close() error {
	ret := _m.Called()

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Count provides a mock function with given fields: locator
func (_m *MockInterface) Count(locator store.Locator) (int, error) {
	ret := _m.Called(locator)

	var r0 int
	if rf, ok := ret.Get(0).(func(store.Locator) int); ok {
		r0 = rf(locator)
	} else {
		r0 = ret.Get(0).(int)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(store.Locator) error); ok {
		r1 = rf(locator)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Create provides a mock function with given fields: comment
func (_m *MockInterface) Create(comment store.Comment) (string, error) {
	ret := _m.Called(comment)

	var r0 string
	if rf, ok := ret.Get(0).(func(store.Comment) string); ok {
		r0 = rf(comment)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(store.Comment) error); ok {
		r1 = rf(comment)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Delete provides a mock function with given fields: locator, commentID, mode
func (_m *MockInterface) Delete(locator store.Locator, commentID string, mode store.DeleteMode) error {
	ret := _m.Called(locator, commentID, mode)

	var r0 error
	if rf, ok := ret.Get(0).(func(store.Locator, string, store.DeleteMode) error); ok {
		r0 = rf(locator, commentID, mode)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteAll provides a mock function with given fields: siteID
func (_m *MockInterface) DeleteAll(siteID string) error {
	ret := _m.Called(siteID)

	var r0 error
	if rf, ok := ret.Get(0).(func(string) error); ok {
		r0 = rf(siteID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteUser provides a mock function with given fields: siteID, userID
func (_m *MockInterface) DeleteUser(siteID string, userID string) error {
	ret := _m.Called(siteID, userID)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string) error); ok {
		r0 = rf(siteID, userID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Find provides a mock function with given fields: locator, sort
func (_m *MockInterface) Find(locator store.Locator, sort string) ([]store.Comment, error) {
	ret := _m.Called(locator, sort)

	var r0 []store.Comment
	if rf, ok := ret.Get(0).(func(store.Locator, string) []store.Comment); ok {
		r0 = rf(locator, sort)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]store.Comment)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(store.Locator, string) error); ok {
		r1 = rf(locator, sort)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Get provides a mock function with given fields: locator, commentID
func (_m *MockInterface) Get(locator store.Locator, commentID string) (store.Comment, error) {
	ret := _m.Called(locator, commentID)

	var r0 store.Comment
	if rf, ok := ret.Get(0).(func(store.Locator, string) store.Comment); ok {
		r0 = rf(locator, commentID)
	} else {
		r0 = ret.Get(0).(store.Comment)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(store.Locator, string) error); ok {
		r1 = rf(locator, commentID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Info provides a mock function with given fields: locator, readonlyAge
func (_m *MockInterface) Info(locator store.Locator, readonlyAge int) (store.PostInfo, error) {
	ret := _m.Called(locator, readonlyAge)

	var r0 store.PostInfo
	if rf, ok := ret.Get(0).(func(store.Locator, int) store.PostInfo); ok {
		r0 = rf(locator, readonlyAge)
	} else {
		r0 = ret.Get(0).(store.PostInfo)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(store.Locator, int) error); ok {
		r1 = rf(locator, readonlyAge)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IsBlocked provides a mock function with given fields: siteID, userID
func (_m *MockInterface) IsBlocked(siteID string, userID string) bool {
	ret := _m.Called(siteID, userID)

	var r0 bool
	if rf, ok := ret.Get(0).(func(string, string) bool); ok {
		r0 = rf(siteID, userID)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// IsReadOnly provides a mock function with given fields: locator
func (_m *MockInterface) IsReadOnly(locator store.Locator) bool {
	ret := _m.Called(locator)

	var r0 bool
	if rf, ok := ret.Get(0).(func(store.Locator) bool); ok {
		r0 = rf(locator)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// IsVerified provides a mock function with given fields: siteID, userID
func (_m *MockInterface) IsVerified(siteID string, userID string) bool {
	ret := _m.Called(siteID, userID)

	var r0 bool
	if rf, ok := ret.Get(0).(func(string, string) bool); ok {
		r0 = rf(siteID, userID)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// Last provides a mock function with given fields: siteID, limit, since
func (_m *MockInterface) Last(siteID string, limit int, since time.Time) ([]store.Comment, error) {
	ret := _m.Called(siteID, limit, since)

	var r0 []store.Comment
	if rf, ok := ret.Get(0).(func(string, int, time.Time) []store.Comment); ok {
		r0 = rf(siteID, limit, since)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]store.Comment)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, int, time.Time) error); ok {
		r1 = rf(siteID, limit, since)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// List provides a mock function with given fields: siteID, limit, skip
func (_m *MockInterface) List(siteID string, limit int, skip int) ([]store.PostInfo, error) {
	ret := _m.Called(siteID, limit, skip)

	var r0 []store.PostInfo
	if rf, ok := ret.Get(0).(func(string, int, int) []store.PostInfo); ok {
		r0 = rf(siteID, limit, skip)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]store.PostInfo)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, int, int) error); ok {
		r1 = rf(siteID, limit, skip)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Put provides a mock function with given fields: locator, comment
func (_m *MockInterface) Put(locator store.Locator, comment store.Comment) error {
	ret := _m.Called(locator, comment)

	var r0 error
	if rf, ok := ret.Get(0).(func(store.Locator, store.Comment) error); ok {
		r0 = rf(locator, comment)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SetBlock provides a mock function with given fields: siteID, userID, status, ttl
func (_m *MockInterface) SetBlock(siteID string, userID string, status bool, ttl time.Duration) error {
	ret := _m.Called(siteID, userID, status, ttl)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, bool, time.Duration) error); ok {
		r0 = rf(siteID, userID, status, ttl)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SetReadOnly provides a mock function with given fields: locator, status
func (_m *MockInterface) SetReadOnly(locator store.Locator, status bool) error {
	ret := _m.Called(locator, status)

	var r0 error
	if rf, ok := ret.Get(0).(func(store.Locator, bool) error); ok {
		r0 = rf(locator, status)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SetVerified provides a mock function with given fields: siteID, userID, status
func (_m *MockInterface) SetVerified(siteID string, userID string, status bool) error {
	ret := _m.Called(siteID, userID, status)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, bool) error); ok {
		r0 = rf(siteID, userID, status)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// User provides a mock function with given fields: siteID, userID, limit, skip
func (_m *MockInterface) User(siteID string, userID string, limit int, skip int) ([]store.Comment, error) {
	ret := _m.Called(siteID, userID, limit, skip)

	var r0 []store.Comment
	if rf, ok := ret.Get(0).(func(string, string, int, int) []store.Comment); ok {
		r0 = rf(siteID, userID, limit, skip)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]store.Comment)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, int, int) error); ok {
		r1 = rf(siteID, userID, limit, skip)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UserCount provides a mock function with given fields: siteID, userID
func (_m *MockInterface) UserCount(siteID string, userID string) (int, error) {
	ret := _m.Called(siteID, userID)

	var r0 int
	if rf, ok := ret.Get(0).(func(string, string) int); ok {
		r0 = rf(siteID, userID)
	} else {
		r0 = ret.Get(0).(int)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string) error); ok {
		r1 = rf(siteID, userID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Verified provides a mock function with given fields: siteID
func (_m *MockInterface) Verified(siteID string) ([]string, error) {
	ret := _m.Called(siteID)

	var r0 []string
	if rf, ok := ret.Get(0).(func(string) []string); ok {
		r0 = rf(siteID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(siteID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}
